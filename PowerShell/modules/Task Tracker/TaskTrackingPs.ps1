<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute
#>

# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#Requires -Modules PSLogging

# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User – $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users – $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

# Index:
# 1. <# Help #>
# 2. #Requires
# 3. [Header]
# 4. [Script Parameters]
# 5. [Initialisations]
# 6. [Modules]
# 7. [Declarations]
# 8. [Functions]
# 9. [Execution]
# 10. [Footer]

# Tested with PowerShell versions:
# 5.1
# Get PowerShell version:
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/call.html
# https://ss64.com/ps/syntax-scriptblock.html
# When passing a variable to a scriptblock it is important to consider the variable scope.
#    Each time the scriptblock is run; it will dynamically read the current value of the variable.
#    When a scriptblock is run using the “&” (call) operator, updates to a variable are not reflected in the parent scope.
#    When a scriptblock is run using the “.” (dot) operator, updates to a variable apply to the current scope.
# help about_Scripts
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# https://ss64.com/ps/source.html
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd

# To run help:
# Get-Help "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

#[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false,
  
  [Parameter(Mandatory=$false)]
  [string]$TaskList = ".\Task-TrackingPs-tasks.csv",
  
  [Parameter(Mandatory=$false)]
  [string]$TimeLog = ".\Task-TrackingPs-time-log.csv"
)

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Only load functions of script. Do not execute Main script block.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initialisations]---------------------------------------------------

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name:"
Write-Verbose "$ScriptName"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
Write-Verbose "Script home directory:"
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "$ScriptDir"
$ScriptDir = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "$ScriptDir"
$ScriptDir = $PSScriptRoot # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
#$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
#$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue"
#$VerbosePreference = "Continue"

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Verbose "Current PowerShell version = $($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor)"
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
    Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
	Write-Debug "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Verbose "TaskList = $TaskList"
#$TaskList = ".\$MyInvocation.MyCommand.Name-tasks.csv"
Write-Verbose "TaskList = $TaskList"
#$TaskList = ".\$ScriptName-tasks.csv"
Write-Verbose "TaskList = $TaskList"

Write-Verbose "WorkLog = $TimeLog"
#$TimeLog = ".\$MyInvocation.MyCommand.Name-work-log.csv"
Write-Verbose "WorkLog = $TimeLog"
#$TimeLog = ".\$ScriptName-work-log.csv"
Write-Verbose "WorkLog = $TimeLog"

#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules & Snap-ins
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

Write-Verbose `r`n
Write-Verbose "Module import complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$sLogPath = $ScriptDir
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Only load functions of script. Do not execute Main script block.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

<#
help about_Automatic_Variables
help about_Comment_Based_Help
help about_Functions
help about_Functions_Advanced
help about_Functions_Advanced_Methods
help about_Functions_Advanced_Parameters
help about_Functions_CmdletBindingAttribute
help about_Functions_OutputTypeAttribute
help about_Parameters
help about_Profiles
help about_Scopes
help about_Script_Blocks
Get-Verb
#>

#Index of functions:
# 1. <FunctionName> Example Function
# 2. Start-PSAdmin
# 3. Get-ScriptDirectory1
# 4. Get-ScriptDirectory2
# 5. Get-ScriptDirectory3
# 6. Write-HorizontalRule
# 7. Write-HorizontalRuleAdv

<# Function <FunctionName> {
  Param ()

  Begin {
    Write-LogInfo -LogPath $sLogFile -Message '<description of what is going on>...'
  }

  Process {
    Try {
      <code goes here>
    }

    Catch {
      Write-LogError -LogPath $sLogFile -Message $_.Exception -ExitGracefully
      Break
    }
  }

  End {
    If ($?) {
      Write-LogInfo -LogPath $sLogFile -Message 'Completed Successfully.'
      Write-LogInfo -LogPath $sLogFile -Message ' '
    }
  }
} #> # End <FunctionName> function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}

function Get-ScriptDirectory1 { #https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
    Split-Path $script:MyInvocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory2 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
    # For PowerShell 3.0 users - following works for both modules and script files:
    Split-Path -parent $PSCommandPath
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory3 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
  $Invocation = (Get-Variable MyInvocation -Scope 1).Value
  Split-Path $Invocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#.SYNOPSIS
# <Overview of script>

#.DESCRIPTION
# <Brief description of script>

#.PARAMETER HRtype
# Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 

#.NOTES
# <Notes Here>
Function Write-HorizontalRule {
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Write-HorizontalRuleAdv {
  
  # .DESCRIPTION
  #  <Brief description of script>
  
  # .PARAMETER HRtype
  # Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 
  
  # .PARAMETER Endcaps
  # Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
  
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
    
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  #Write-Verbose "Running function: $FunctionName"
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
    # $VerbosePreference = "Continue"
    # $VerbosePreference = "SilentlyContinue"
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue"
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }

} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------


function Read-Choice { # https://www.zerrouki.com/powershell-menus-host-ui-promptforchoice-defined-or-dynamic/
	Param(
		[System.String]$Message,
		
		[Parameter(Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String[]]$Choices,
		
		[System.Int32]$DefaultChoice = 1,
		
		[System.String]$Title = [string]::Empty
	)
	[System.Management.Automation.Host.ChoiceDescription[]]$Poss = $Choices | ForEach-Object {
		New-Object System.Management.Automation.Host.ChoiceDescription "&$($_)", "Sets $_ as an answer."
	}
	$Host.UI.PromptForChoice( $Title, $Message, $Poss, $DefaultChoice )
} # End Read-Choice function -------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Select-IPAddress { # https://www.zerrouki.com/powershell-menus-host-ui-promptforchoice-defined-or-dynamic/
	[cmdletbinding()]
	Param(
		[System.String]$ComputerName = 'localhost'
	)
	$IPs = Get-WmiObject -ComputerName $ComputerName -Class Win32_NetworkAdapterConfiguration -Filter "IPEnabled='True'" | ForEach-Object {
		$_.IPAddress
	} | Where-Object {
		$_ -match "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
	}
	#Write-Log $IPs
	Write-Host $IPs
	Write-LogInfo -LogPath $sLogFile -Message "$IPs"
	if($IPs -is [array]){
		Write-Host "`nServer $ComputerName uses those IP addresses:`n"
		$IPs | ForEach-Object { $Id = 0 } { Write-Host "$Id : $_"; $Id++ }
		$IPs[(Read-Choice -Message "`nChoose IPAddress" -Choices (0..($ID-1)) -DefaultChoice 0)]
	}else{
		$IPs
	}
} # End Select-IPAddress function --------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Check-Command($cmdname)
{
    return [bool](Get-Command -Name $cmdname -ErrorAction SilentlyContinue)
	
	# How to use (for example):
	
	#if (Check-Command -cmdname 'Invoke-WebRequest') {
	#	Invoke-WebRequest $link -OutFile $destination
	#	$CommandExists = $True
	#} else {
	#	$webclient.DownloadFile($link, $destination)
	#	$CommandExists = $False
	#}
	
} # End Check-Command function -----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Create-NewTask { # New Task - $ChoiceNewTask
	
	Param (
		#Script parameters go here
		# https://ss64.com/ps/syntax-args.html
		[Parameter(Mandatory=$true)]
		[string]$TaskListPath,
		
		[Parameter(Mandatory=$true)]
		[string]$LogFilePath
	)
	
	#$TaskList #CSV
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	Write-Verbose "Create task list Headers: "
	#$TaskList_Headers = "ID"
	$TaskList_Headers = "TaskName"
	# Get-Date -format o # 'YYYY-MM-DDThh-mm-ss.ms-TimeZone' E.g. '2019-09-16T22:03:23.9929606-07:00'
	$TaskList_Headers += ",TimeStamp_Added (YYYY-MM-DDThh-mm-ss.ms-TimeZone)"
	$TaskList_Headers += ",TimeStamp_LastWorkedOn (YYYY-MM-DDThh-mm-ss.ms-TimeZone)"
	$TaskList_Headers += ",TimeStamp_Completed (YYYY-MM-DDThh-mm-ss.ms-TimeZone)"
	$TaskList_Headers += ",Estimated_Time"
	$TaskList_Headers += ",Status"
	$TaskList_Headers += ",Tags"
	
	# Tags: (Tag1;Tag2;LastTag)
	# $TaskList_Tags = "Resume;Printer;Email"
	
	<#
	# TaskList_Status:
	$TaskList_Status = "Active"
	$TaskList_Status = "Completed"
	$TaskList_Status = "Deleted"
	$TaskList_Status = "In-Progress"
	$TaskList_Status = "On-Hold"
	#>
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#Write-Verbose "New Task. (`$ChoiceNewTask)"
	do {
		Write-Host `n
		Write-Host "Create New Task"
		Write-HorizontalRuleAdv -HRtype DashedLine
		$NewTaskName = Read-Host -Prompt "New Task Name"
		If ($NewTaskName -eq "") {
			Write-Warning "New Task Name cannot be empty."
		}
	}
	until ($NewTaskName -ne "")

	Write-Verbose "New Task: '$NewTaskName'"
	
	$NewTask_Estimated_Time = Read-Host -Prompt "Estimated hours to complete"
	Write-Verbose "Estimated hours: '$NewTask_Estimated_Time'"
	
	$NewTask_TimeStamp_Added = Get-Date -format o # (YYYY-MM-DDThh-mm-ss.ms-TimeZone) 
	Write-Verbose "TimeStamp_Added: '$NewTask_TimeStamp_Added'"
	$NewTask_TimeStamp_LastWorkedOn = "" # (YYYY-MM-DDThh-mm-ss.ms-TimeZone) 
	Write-Verbose "TimeStamp_LastWorkedOn: '$NewTask_TimeStamp_LastWorkedOn'"
	$NewTask_TimeStamp_Completed = "" # (YYYY-MM-DDThh-mm-ss.ms-TimeZone) 
	Write-Verbose "TimeStamp_Completed: '$NewTask_TimeStamp_Completed'"
	
	# TaskList_Status:
	$TaskList_Status = "Active"
	#$TaskList_Status = "Completed"
	#$TaskList_Status = "Deleted"
	#$TaskList_Status = "In-Progress"
	#$TaskList_Status = "On-Hold"
	
	$TaskList_Tags = ""
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Build New Task entry
	$NewTaskEntry = "$($NewTaskName)"
	$NewTaskEntry += ",$($NewTask_TimeStamp_Added)"
	$NewTaskEntry += ",$($NewTask_TimeStamp_LastWorkedOn)"
	$NewTaskEntry += ",$($NewTask_TimeStamp_Completed)"
	$NewTaskEntry += ",$($NewTask_Estimated_Time)"
	$NewTaskEntry += ",$($TaskList_Status)"
	$NewTaskEntry += ",$($TaskList_Tags)"
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "Adding New Task to file: '$TaskListPath'"
	Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
	#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
	
	# Create $TaskListPath file if it does not exist
	If (!(Test-Path $TaskListPath)) {
		Write-Verbose "`$TaskListPath '$TaskListPath' does not exist. Creating file . . ."
		Write-LogInfo -LogPath $LogFilePath -Message "Creating new Task List file: '$TaskListPath'"
		Write-Debug "Creating Task List file: '$TaskListPath'"
		$TaskList_Headers > $TaskListPath
		$NewTaskEntry >> $TaskListPath
	} else {
		Write-Verbose "`$TaskListPath '$TaskListPath' exists."
		Write-Verbose "Appending to file . . ."
		Write-LogInfo -LogPath $LogFilePath -Message "Adding New Task to file: '$NewTaskName' '$TaskListPath'"
		Write-Debug "Appending New Task to file: '$TaskListPath'"
		$NewTaskEntry >> $TaskListPath
	}
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "Get line # of newly created task."
	
	#https://powershell-tips.blogspot.com/2011/05/display-top-n-lines-or-last-1n-lines-of.html
	#Get-Content $TaskListPath | Select-Object -Last 1
	#Get-Content $TaskListPath | Select-Object -Last 1 | Select-Object -Property *
	
	#https://stackoverflow.com/questions/50044959/get-a-line-number-on-powershell
	
	$LastEntry = Get-Content $TaskListPath | Select-Object -Last 1
	$LastLine = Get-Content $TaskListPath | Select-String $LastEntry
	$LastLineNumber = $LastLine.LineNumber
	Write-Verbose "Last Entry = '$LastEntry'"
	Write-Verbose "Last Line = '$LastLine'"
	Write-Verbose "Last line of file = '$LastLineNumber'"
	PAUSE
	
	# Select-String returns the line number for you. You're just looking at the wrong property. Change your code to:
	
	$search="Mustard"
	$linenumber= Get-Content $TaskListPath | select-string $search
	$linenumber.LineNumber
	
	
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "Automatically Select Newly created task."
	
} # End Create-NewTask function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Select-PomodoroMode { # Select Pomodoro Mode - $ChoiceSelectPomodoroMode
	# -----------------------------------------------------------------------------------------------------------------------
	# Build Menu
	# -----------------------------------------------------------------------------------------------------------------------
	CLS
	Write-Host `r`n
	Write-Host "Choose Pomodoro Mode:" -ForegroundColor Yellow
	Write-HorizontalRuleAdv -HRtype DashedLine
	if ($Pomodoro_Mode) {
	Write-Host "  Currently Selected: '$($Pomodoro_Mode)'" -ForegroundColor Green -BackgroundColor Black
	Write-HorizontalRuleAdv -HRtype DashedLine
	}
	# Pomodoro_Mode:
	#>>>>>>>>>> -----------------------------------------------------------------------------------------------------------------------
	Write-Host "  P - Classic [P]omodoro - 25 min work / 5 min break ( 4 hour cycle = 3 hours 20 min work / 40 min break )"
	Write-Host "            - Finish a task early, and enjoy the remaining 30 min as break."
	Write-Host "            - After 4 total hours, take a required 30min - 1 hour break."
	Write-Host "            - Log distractions when you get sidetracked, but they do not affect anything."
	Write-Host "            - PAUSE only when you have official Unplanned Work (such as co-worker or boss walking in with Urgent task)"
	#>>>>>>>>>> -----------------------------------------------------------------------------------------------------------------------
	Write-Host "  E - [E]asy Pomodoro - 15 min work / 5 min break ( 4 hour cycle = 3 hours work / 1 hour break )"
	Write-Host "  R - [R]everse Pomodoro - 5 min work / 25 min break"
	Write-Host "  T - [T]raditional - Clock runs continuously. Use PAUSE to take breaks manually."
	#Write-Host "  C - [C]ustom - Choose work/break cycle"
	Write-Host "  Q - [Q]uit - Cancel Selection"
	#>>>>>>>>>> -----------------------------------------------------------------------------------------------------------------------
	Write-HorizontalRuleAdv -HRtype DashedLine
	
	# -----------------------------------------------------------------------------------------------------------------------
	# Build Choice Prompt
	# -----------------------------------------------------------------------------------------------------------------------
	
	# -----------------------------------------------------------------------------------------------------------------------
	# Execute Choice Prompt
	# -----------------------------------------------------------------------------------------------------------------------
	#$Pomodoro_Choice = Read-Host -Prompt "Choose Pomodoro mode"
	$global:Pomodoro_Choice = Read-Host -Prompt "Choose Pomodoro mode"
	
	# -----------------------------------------------------------------------------------------------------------------------
	# Interpret answer
	# -----------------------------------------------------------------------------------------------------------------------
	#help about_switch
	#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
	Write-Verbose "Answer = '$Pomodoro_Choice'"
	switch ($Pomodoro_Choice)
	{
		'P'	{ # P - Classic [P]omodoro
			$Pomodoro_Mode = "Classic Pomodoro"
			$global:Pomodoro_Mode = "Classic Pomodoro"
			Write-Verbose "'$Pomodoro_Mode' selected."
			#Break #help about_Break
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		'E' { # E - [E]asy Pomodoro
			$Pomodoro_Mode = "Easy Pomodoro"
			$global:Pomodoro_Mode = "Easy Pomodoro"
			Write-Verbose "'$Pomodoro_Mode' selected."
			#Break #help about_Break
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		'R' { # R - [R]everse Pomodoro
			$Pomodoro_Mode = "Reverse Pomodoro"
			$global:Pomodoro_Mode = "Reverse Pomodoro"
			Write-Verbose "'$Pomodoro_Mode' selected."
			#Break #help about_Break
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		'T' { # T - [T]raditional
			$Pomodoro_Mode = "Traditional Clock"
			$global:Pomodoro_Mode = "Traditional Clock"
			Write-Verbose "'$Pomodoro_Mode' selected."
			#Break #help about_Break
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		'C' { # C - [C]ustom
			$Pomodoro_Mode = "Custom Pomodoro"
			$global:Pomodoro_Mode = "Custom Pomodoro"
			Write-Verbose "'$Pomodoro_Mode' selected."
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		'Q' { # Q - [Q]uit - Cancel Selection
			Write-Verbose "Quit option selected."
			#Break #help about_Break
			#Return #help about_Return
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		default { # Choice not recognized.
			Write-Host `n
			Write-Host "Choice `"$Pomodoro_Choice`" not recognized."
			Write-HorizontalRuleAdv -HRtype DashedLine
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
	}
	Write-Verbose "End of switch choice cycle."
	Write-Host `n
	#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
	#CLS
	
	# -----------------------------------------------------------------------------------------------------------------------
	# Return values
	# -----------------------------------------------------------------------------------------------------------------------
	
	#$Pomodoro_Mode = "Classic Pomodoro"
	#$Pomodoro_Mode = "Easy Pomodoro"
	#$Pomodoro_Mode = "Reverse Pomodoro"
	#$Pomodoro_Mode = "Traditional Clock"
	#$Pomodoro_Mode = "Custom Pomodoro"
	
	<#
	$Pomodoro_Choice = 'P'
	$Pomodoro_Choice = 'E'
	$Pomodoro_Choice = 'R'
	$Pomodoro_Choice = 'T'
	#$Pomodoro_Choice = 'C' # Not in use
	$Pomodoro_Choice = 'Q'
	#>
	
} # End Select-PomodoroMode function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

If (!($sLogPath)) { Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion }

# run "help about_comment_based_help" - I want to display formatted help for a function or script. Use comment-based help instead - run "help about_comment_based_help". PowerShell will format it for you.
# https://technet.microsoft.com/en-us/library/dd819489.aspx
# Write-Host - You almost never need to do it. 
# Write-Information - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints grey text. Can be overridden with -InformationAction Continue
# Write-Verbose - Writes yellow VERBOSE: messages (9 chars). Can be turned on/off by running script with -Verbose parameter.
# Write-Debug - Pauses script execution every time it's called. Can be turned on/off by running script with -Debug parameter.
# Write-Warning - Writes yellow WARNING: messages (9 chars), regardless of -Verbose or -Debug switches.
# Write-Error - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints in red text, "Entire Script path: Error message." E.g. C:\Users\G\Documents\SpiderOak Hive\Consulting\2018-04-06 SodaLakeNetworking\Manage-SodaLakeData.ps1 : TEST ERROR.
# Write-Output - I just need to display some text! Do you really? PowerShell works better with objects, and that's what your script should be outputting, by means of Write-Output. Let PowerShell's Format cmdlets turn those objects into text like lists and tables.
# Write-Progress - Makes a green and yellow progress bar appear at the top part of the command window.

#Write-Host "Script Main beginning." $MyInvocation.MyCommand.Name
Write-Information -MessageData "Will only display if set defaults display infromational messages."
#Write-Information -MessageData "Test infromational messages." -InformationAction Continue
Write-Verbose "Script Main beginning. $ScriptName"
Write-Verbose "Debug preference = $DebugPreference"
#Write-Debug "Script Main beginning." # NOTE: Writing debug text will PAUSE script execution automatically.
#Write-Warning "Test Warning."
#Write-Error -Message "TEST ERROR. TEST ERROR. TEST ERROR. TEST ERROR." -Category InvalidData -ErrorId TEST_ID
#For ($I = 1; $I -le 100; $I++) {Write-Progress -Activity "Test in progress..." -Status "$I% Complete:" -PercentComplete $I;}
#For ($I = 1; $I -le 1000; $I++) {Write-Progress -Activity "Test in progress..." -Status "$($I / 10)% Complete:" -PercentComplete ($I/10)}

# Write-LogInfo – Writes an informational message to the log file
# Write-LogWarning – Writes a warning message to the log file (with the format of WARNING: )
# Write-LogError – Writes an error message to the log file (with the format of ERROR: ). In addition, optionally calls Stop-Log to end logging and terminate the calling script on fatal error.

Write-LogInfo -LogPath $sLogFile -Message "-----------------------------------------------------------------------------------------------------------------------"
Write-LogInfo -LogPath $sLogFile -Message "[TIMESTAMP]: $($Time)"

#Write-LogInfo -LogPath $sLogFile -Message "Test log info write."
#Write-LogWarning -LogPath $sLogFile -Message "Test log warning write."
#Write-LogError -LogPath $sLogFile -Message "Test log error write."

# https://ss64.com/ps/read-host.html
#$Choice = Read-Host -Prompt "Enter text to be caputred" # CHOICE (Read-Host automatically adds colon at the end of prompt)
# https://ss64.com/ps/syntax-esc.html
#Write-Host "Captured text = `"$Choice`""

#Read-Host "Press ENTER key to continue . . . " # PAUSE (Read-Host automatically adds colon : at the end of prompt)
#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# -----------------------------------------------------------------------------------------------------------------------
# =======================================================================================================================
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
#
##Script MAIN Execution goes here
#Clear-Host # CLS

# =======================================================================================================================
# Index:
# Twilio send SMS function:
# =======================================================================================================================

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# =======================================================================================================================
# Twilio send SMS function:
# =======================================================================================================================

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Check if environment variables are already set or not, and set them if not

$NewEnvVarName = ""
$NewEnvVarValue = ""

Write-Verbose "Setting environment variables: $NewEnvVarName, $NewEnvVarValue"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -----------------------------------------------------------------------------------------------------------------------

# Update System Environment Variables from external file

$TwilioAuthFile = ".\Twilio-Auth_template.ps1"
$TwilioAuthFile = ".\Twilio-Auth.ps1"

#[Environment]::SetEnvironmentVariable("TWILIO_ACCOUNT_SID", "your_account_sid", "User")
#[Environment]::SetEnvironmentVariable("TWILIO_ACCOUNT_SID", "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "User")

#[Environment]::SetEnvironmentVariable("TWILIO_AUTH_TOKEN", "your_auth_token", "User")
#[Environment]::SetEnvironmentVariable("TWILIO_AUTH_TOKEN", "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "User")

# Twilio Phone number to send SMS from
#[Environment]::SetEnvironmentVariable("TWILIO_NUMBER", "+12345678901", "User")

# Phone number to send SMS to
#[Environment]::SetEnvironmentVariable("TWILIO_VERIFIED_CALLERID", "+12345678901", "User")

# -----------------------------------------------------------------------------------------------------------------------
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Check if 'refreshenv' command exists (command exit success, no error code)

#help about_Automatic_Variables
# $?   Contains the execution status of the last operation. It contains TRUE if the last operation succeeded and FALSE if it failed.
# $LastExitCode   Contains the exit code of the last Windows-based program that was run.

$CommandToCheck = "refreshenv"

Write-Verbose "Check if '$CommandToCheck' command exists."

if (Check-Command -cmdname $CommandToCheck) {$CommandExists = $True} else {$CommandExists = $False}

Write-Verbose "'$CommandToCheck' command exists = `"$CommandExists`""
Write-Verbose "'$CommandToCheck' command execution status = `"$?`""
Write-Verbose "'$CommandToCheck' command exit code = `"$LastExitCode`""

#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Run 'refreshenv' if exists, or end & restart script if it doesn't exist.

Write-Verbose "Refresh environment variables using '$CommandToCheck' command from Chocolatey (if exists) since we just updated them."

if ($CommandExists -eq $True) {
	Write-Verbose "Refresh environment variables using '$CommandToCheck' command from Chocolatey, since we just updated them."
	Write-Verbose "Running $($CommandToCheck):"
	refreshenv
} else {
	Write-Verbose "'$CommandToCheck' does not exist."
	Write-Verbose "Must restart this script to update environment variables."
	Return # help about_Return
}

# -----------------------------------------------------------------------------------------------------------------------

# Body of SMS Text:
# Sent from your Twilio trial account - 
$BodySMS = "Hello from PowerShell

Hello

World."

# -----------------------------------------------------------------------------------------------------------------------

$APIurl = "https://api.twilio.com/2010-04-01/Accounts/$sid/Messages.json"
$APIurl = "https://api.twilio.com/2010-04-01/Accounts/"

# Pull in Twilio account info, previously set as environment variables
$sid = $env:TWILIO_ACCOUNT_SID
$token = $env:TWILIO_AUTH_TOKEN
$number = $env:TWILIO_NUMBER
$SendToNumber = $env:TWILIO_VERIFIED_CALLERID

# Twilio API endpoint and POST params
$url = "https://api.twilio.com/2010-04-01/Accounts/$sid/Messages.json"
$params = @{ To = $SendToNumber; From = $number; Body = $BodySMS }

# Create a credential object for HTTP basic auth
$p = $token | ConvertTo-SecureString -asPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential($sid, $p)

# Set SecurityProtocol to use with Twilio API
# Starting June 26, 2019, the Twilio REST API will only support connections that use TLS v1.2 and strong cipher suites
# https://support.twilio.com/hc/en-us/articles/360006751753-Tips-for-Upgrading-Your-Environment-to-Support-Twilio-REST-API-s-TLS-and-Strong-Cipher-Suite-Changes
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Make API request, selecting JSON properties from response
#Invoke-WebRequest $url -Method Post -Credential $credential -Body $params -UseBasicParsing |
#ConvertFrom-Json | Select sid, body

#$Response = Invoke-WebRequest $url -Method Post -Credential $credential -Body $params -UseBasicParsing

# Invoke-RestMethod

#Write-Host $Response

#$Response | ConvertFrom-Json

<# 
{"sid": "SM7582c4576cbd49669fe0409bbc54a69c", 
"date_created": "Mon, 01 Jul 2019 09:47:51 +0000", 
"date_updated": "Mon, 01 Jul 2019 09:47:51 +0000", 
"date_sent": null, 
"account_sid": "AC233dffdc2d0f89ca6843bc2186f6cb84", 
"to": "+14804155032", 
"from": "+16028992009", 
"messaging_service_sid": null, 
"body": "Sent from your
 Twilio trial account - Hello from PowerShell\r\n\r\nHello\r\n\r\nWorld.", 
"status": "queued", 
"num_segments": "1", 
"num_media": "0", 
"direction": "outbound-api", 
"api_version": "2010-04-01", 
"price": null, 
"price_unit": "USD", 
"error_code": null, 
"error_message": null, 
"uri": "/2010-04-01/Accounts/AC233dffdc2d0f89ca6843bc2186f6cb84/Messages/SM7582c4576cbd49669fe0409bbc54a69c.json", 
"subresource_uris": {"media": "/2010-04-01/Accounts/AC233dffdc2d0f89ca6843bc2186f6cb84/Messages/SM7582c4576cbd49669fe0409bbc54a69c/Media.json"}}
#>

#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# =======================================================================================================================
# Time to get serious
# =======================================================================================================================

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Check if files exist

if (Test-Path $TaskList) {
	Write-Verbose "Task list already exists: $TaskList"
} else {
	Write-Verbose "Task list does not exist: $TaskList"
}

If (Test-Path $TimeLog) {
	Write-Verbose "Time log already exists: $TimeLog"
} else {
	Write-Verbose "Time log does not exist: $TimeLog"
}

#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# =======================================================================================================================

# Notes Reference of data file structure

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#$TimeLog #CSV
# Headers:
# TimeStamp (YYYY-MM-DD_HH-MM-SS), Date (YYYY-MM-DD), Time (HH:MM:SS AM), TimeZone (MST), Hostname, TaskList_ID, TaskList_Name, TimeLog_Type, Pomodoro_Mode

# TimeLog_Type:
#$TimeLog_Type = "WorkStart"
#$TimeLog_Type = "TimeStart"
#$TimeLog_Type = "TimeStop"
#$TimeLog_Type = "DistractionTimeStamp"
#$TimeLog_Type = "PAUSE"
#$TimeLog_Type = "UN-PAUSE"
#$TimeLog_Type = "WorkStop"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Pomodoro_Mode:
# Classic Pomodoro - 25 min work / 5 min break ( 4 hour cycle = 3 hours 20 min work / 40 min break )
	# Finish a task early, and enjoy the remaining 30 min as break.
	# After 4 total hours, take a required 30min - 1 hour break.
	# Log distractions when you get sidetracked, but they do not affect anything.
	# PAUSE only when you have official Unplanned Work (such as co-worker or boss walking in with Urgent task)
# Easy Pomodoro - 15 min work / 5 min break ( 4 hour cycle = 3 hours work / 1 hour break )
# Reverse Pomodoro - 5 min work / 25 min break
# Traditional - Clock runs continuously. Use PAUSE to take breaks manually.
# Custom - Choose work/break cycle

#$Pomodoro_Mode = "Classic Pomodoro"
#$Pomodoro_Mode = "Easy Pomodoro"
#$Pomodoro_Mode = "Reverse Pomodoro"
#$Pomodoro_Mode = "Traditional Clock"
#$Pomodoro_Mode = "Custom Pomodoro"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# -----------------------------------------------------------------------------------------------------------------------

do
{
	# -----------------------------------------------------------------------------------------------------------------------
	# Build Menu
	# -----------------------------------------------------------------------------------------------------------------------
	Clear-Host # CLS
	Write-HorizontalRuleAdv -HRtype DashedLine
	#Write-Host `n
	Write-Host "  Select option:" -ForegroundColor Yellow
	
	If (Test-Path $TaskList) {
	Write-Host "    T - Select [T]ask"
	}
	
	Write-Host "    N - [N]ew Task"
	
	If (Test-Path $TaskList) {
	Write-Host "    M - [M]anage Tasks" # Add tags retroactively
	
	Write-Host "    C - Mark Task [C]omplete"
	}
	
	If (Test-Path $TimeLog) {
	Write-Host "    H - Calculate Total [H]ours"
	}
	
	Write-Host "    S - [S]tart Timer"
	
	if ($Pomodoro_Mode) {
	Write-Host "    P - Select [P]omodoro Mode               Currently Selected: '$($Pomodoro_Mode)'" -ForegroundColor Green
	#>>>>>>>>>> -----------------------------------------------------------------------------------------------------------------------
	} else {
	Write-Host "    P - Select [P]omodoro Mode"
	}
	
	#Write-Host "    F - [F]ilter by Tags"
	
	#Write-Host "    A - Manage Tags"
	
	Write-Host "    1 - Test 1"
	Write-Host "    Q - [Q]uit"
	#Write-Host `n
	Write-HorizontalRuleAdv -HRtype DashedLine
	Write-Host "Type letter choice, then press ENTER."
	Write-HorizontalRuleAdv -HRtype DashedLine
	#Write-Host "Choose Pipsqueak SQL command to generate."
	# -----------------------------------------------------------------------------------------------------------------------
	# Build Choice Prompt
	# -----------------------------------------------------------------------------------------------------------------------
	# If run from shell, will create a dialog box. If run in script, will show choice text in command line.
	# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
	$Title = "Main Menu"
	$Info = "Choose next action"
	# &Power makes P a Hot Key. 
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$ChoiceSelectTask = New-Object System.Management.Automation.Host.ChoiceDescription "Select &Task", "Select a [T]ask from the Task list: $TaskList"
	
	$ChoiceNewTask = New-Object System.Management.Automation.Host.ChoiceDescription "&New Task", "Create a [N]ew task, and automatically select it."
	
	$ChoiceManageTasks = New-Object System.Management.Automation.Host.ChoiceDescription "&Manage Tasks", "Go to the `"[M]anage Tasks`" menu, to: add tags, delete tasks."
	
	$ChoiceMarkTaskComplete = New-Object System.Management.Automation.Host.ChoiceDescription "Mark Task &Complete", "Mark the currently selected task complete, and archive it."
	
	$ChoiceCalculateTotalHours = New-Object System.Management.Automation.Host.ChoiceDescription "Calculate Total &Hours", "Calculate actual hours spent on tasks vs. predicted hours."
	
	$ChoiceStartTimer = New-Object System.Management.Automation.Host.ChoiceDescription "&Start Timer", "[S]tart timer using selected Pomodoro Mode and add to Time log: $TimeLog"
	
	$ChoiceSelectPomodoroMode = New-Object System.Management.Automation.Host.ChoiceDescription "&Pomodoro Mode", "Select [P]omodoro Mode."
	
	$ChoiceTest = New-Object System.Management.Automation.Host.ChoiceDescription "&1 Test", "[T]est option."
	$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green and exits."
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceSelectTask, $ChoiceNewTask, $ChoiceStartTimer, $ChoiceSelectPomodoroMode, $ChoiceTest, $ChoiceQuit)
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceSelectTask, $ChoiceNewTask, $ChoiceManageTasks, $ChoiceMarkTaskComplete, $ChoiceCalculateTotalHours, $ChoiceStartTimer, $ChoiceSelectPomodoroMode, $ChoiceTest, $ChoiceQuit)
	# default choice: 0 = first Option, 1 = second option, etc.
	[int]$defaultchoice = 1
	# -----------------------------------------------------------------------------------------------------------------------
	# Execute Choice Prompt
	# -----------------------------------------------------------------------------------------------------------------------
	# PromptForChoice() output will always be int https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
	#$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	$answer = Read-Host -Prompt $Info
	# -----------------------------------------------------------------------------------------------------------------------
	# Interpret answer
	# -----------------------------------------------------------------------------------------------------------------------
	#help about_switch
	#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
	Write-Verbose "Answer = $answer"
	switch ($answer)
	{
		# -----------------------------------------------------------------------------------------------------------------------
		'T'	{ # Select Task - $ChoiceSelectTask
			Write-Verbose "Select Task."
			If (!(Test-Path $TaskList)) {
				Write-Warning "`$TaskList '$TaskList' does not exist. Cannot Select Task."
				PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
				Break #help about_Break
			}
			Write-Host `n
			Write-Host "Select Task."
			Write-HorizontalRuleAdv -HRtype DashedLine
			
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		'N' { # New Task - $ChoiceNewTask
			Write-Verbose "New Task. (`$ChoiceNewTask)"
			Write-Verbose "Creating New Task."
			# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			Create-NewTask -TaskListPath $TaskList -LogFilePath $sLogFile
			# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			<#
			Write-Host `n
			Write-Host "Create New Task"
			Write-HorizontalRuleAdv -HRtype DashedLine
			$NewTaskName = Read-Host -Prompt "New Task Name"
			Write-Verbose "New Task: '$NewTaskName'"
			
			$NewTask_Estimated_Time = Read-Host -Prompt "Estimated hours to complete"
			Write-Verbose "Estimated hours: '$NewTask_Estimated_Time'"
			
			$NewTask_TimeStamp_Added = Get-Date -format o # (YYYY-MM-DD_HH-MM-SS), 
			Write-Verbose "TimeStamp_Added: '$NewTask_TimeStamp_Added'"
			$NewTask_TimeStamp_LastWorkedOn = "" # (YYYY-MM-DD_HH-MM-SS), 
			Write-Verbose "TimeStamp_LastWorkedOn: '$NewTask_TimeStamp_LastWorkedOn'"
			$NewTask_TimeStamp_Completed = "" # (YYYY-MM-DD_HH-MM-SS), 
			Write-Verbose "TimeStamp_Completed: '$NewTask_TimeStamp_Completed'"
			
			# TaskList_Status:
			$TaskList_Status = "Active"
			#$TaskList_Status = "Completed"
			#$TaskList_Status = "Deleted"
			#$TaskList_Status = "In-Progress"
			#$TaskList_Status = "On-Hold"
			
			$TaskList_Tags = ""
			
			$NewTaskEntry = "$($NewTaskName)"
			$NewTaskEntry += ",$($NewTask_TimeStamp_Added)"
			$NewTaskEntry += ",$($NewTask_TimeStamp_LastWorkedOn)"
			$NewTaskEntry += ",$($NewTask_TimeStamp_Completed)"
			$NewTaskEntry += ",$($NewTask_Estimated_Time)"
			$NewTaskEntry += ",$($TaskList_Status)"
			$NewTaskEntry += ",$($TaskList_Tags)"
			
			Write-Verbose "Adding New Task to file: '$TaskList'"
			Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			
			# Create $TaskList file if it does not exist
			If (!(Test-Path $TaskList)) {
				Write-Verbose "`$TaskList '$TaskList' does not exist. Creating file."
				Write-LogInfo -LogPath $sLogFile -Message "Creating new Task List file: '$TaskList'"
				Write-Debug "Creating Task List file: '$TaskList'"
				$NewTaskEntry > $TaskList
			} else {
				Write-Verbose "`$TaskList '$TaskList' exists."
				Write-Verbose "Appending to file . . . "
				Write-LogInfo -LogPath $sLogFile -Message "Adding New Task to file: '$NewTaskName' '$TaskList'"
				Write-Debug "Appending New Task to file: '$TaskList'"
				$NewTaskEntry >> $TaskList
			}
			
			#>
			# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			#Break #help about_Break
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		'M' { # Manage Tasks - $ChoiceManageTasks
			Write-Verbose "Manage Tasks."
			Write-Host `n
			Write-Host "Manage Tasks."
			Write-HorizontalRuleAdv -HRtype DashedLine
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		'C' { # Mark Task Complete - $ChoiceMarkTaskComplete
			Write-Verbose "Mark Task Complete."
			Write-Host `n
			Write-Host "Mark Task Complete."
			Write-HorizontalRuleAdv -HRtype DashedLine
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		'H' { # Calculate Total Hours - $ChoiceCalculateTotalHours
			Write-Verbose "Calculate Total Hours."
			Write-Host `n
			Write-Host "Calculate Total Hours."
			Write-HorizontalRuleAdv -HRtype DashedLine
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		'S' { # Start Timer - $ChoiceStartTimer
			Write-Verbose "Start Timer."
			Write-Host `n
			Write-Host "Start Timer."
			Write-HorizontalRuleAdv -HRtype DashedLine
			
			# Check if we have a selected Task.
			
			# No task is selected, ask user if they'd like to select or create one.
			
			$SelectedTaskLine
			$SelectedTaskName
			
			If (!(Test-Path $TaskList)) {
				Write-Verbose "`$TaskList '$TaskList' does not exist."
				do {
					$ChoiceYesNo = Read-Host -Prompt "Create Task to associate with? [Y\N]"
					switch ($ChoiceYesNo) {
						'Y'	{ # Y - Yes
							Write-Verbose "Yes ('$ChoiceYesNo') option selected."
							Write-Verbose "Creating Task first, then Selecting it, then Starting Timer."
							Write-Host `r`n
							Write-Verbose "Creating New Task."
							Create-NewTask -TaskListPath $TaskList -LogFilePath $sLogFile
						}
						'N' { # N - No
							Write-Verbose "No ('$ChoiceYesNo') option selected."
							Write-Verbose "Proceeding with Timer without associating a Task."
							Write-Host `r`n
							$SelectedTaskLine = ""
							$SelectedTaskName = ""
						}
						default { # Choice not recognized.
							Write-Host `r`n
							Write-Host "Choice `"$ChoiceYesNo`" not recognized. Options must me Yes or No."
							#Write-HorizontalRuleAdv -HRtype DashedLine
							Write-Host `r`n
							#Break #help about_Break
							PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
							Write-Host `r`n
							Write-HorizontalRuleAdv -HRtype DashedLine
						}
					}
				}
				until ($ChoiceYesNo -eq 'Y' -Or $ChoiceYesNo -eq 'N')
			} else {
				Write-Verbose "`$TaskList '$TaskList' exists."
				# Check if file has any contents.
				If (!(Test-Path $TaskList)) {
					Write-Verbose "`$TaskList '$TaskList' has contents."
					do {
						$ChoiceYesNo = Read-Host -Prompt "Select New/Existing Task to associate this Time with? [Y\N]"
						switch ($ChoiceYesNo) {
							'Y'	{ # Y - Yes
								Write-Verbose "Yes ('$ChoiceYesNo') option selected."
								Write-Host `r`n
								do {
									$ChoiceAnswer = Read-Host -Prompt "Select [E]xisting Task, Create [N]ew Task, or [C]ancel? [E\N\C]"
									switch ($ChoiceAnswer) {
										'E'	{ # E - Select Existing Task
											Write-Verbose "Select Existing Task ('$ChoiceAnswer') option selected."
											Write-Host `r`n
										}
										'N' { # N - Create New Task
											Write-Verbose "Create New Task ('$ChoiceAnswer') option selected."
											Write-Host `r`n
											Write-Verbose "Creating New Task."
											# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
											Create-NewTask -TaskListPath $TaskList -LogFilePath $sLogFile
											# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
										}
										'C' { # C - Cancel
											Write-Verbose "Cancel ('$ChoiceAnswer') option selected."
											Write-Host `r`n
											Break #help about_Break
										}
										default { # Choice not recognized.
											Write-Host `r`n
											Write-Host "Choice `"$ChoiceAnswer`" not recognized. Options must me Yes or No."
											#Write-HorizontalRuleAdv -HRtype DashedLine
											Write-Host `r`n
											#Break #help about_Break
											PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
											Write-Host `r`n
											Write-HorizontalRuleAdv -HRtype DashedLine
										}
									}
								}
								until ($ChoiceAnswer -eq 'Y' -Or $ChoiceAnswer -eq 'N' -Or $ChoiceAnswer -eq 'C')
								if ($ChoiceAnswer -eq 'C') {Break} #help about_Break
							}
							'N' { # N - No
								Write-Verbose "No ('$ChoiceYesNo') option selected."
								Write-Verbose "Proceeding with Timer without associating a Task."
								Write-Host `r`n
								$SelectedTaskLine = ""
								$SelectedTaskName = ""
							}
							default { # Choice not recognized.
								Write-Host `r`n
								Write-Host "Choice `"$ChoiceYesNo`" not recognized. Options must me Yes or No."
								#Write-HorizontalRuleAdv -HRtype DashedLine
								Write-Host `r`n
								#Break #help about_Break
								PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
								Write-Host `r`n
								Write-HorizontalRuleAdv -HRtype DashedLine
							}
						}
					}
					until ($ChoiceYesNo -eq 'Y' -Or $ChoiceYesNo -eq 'N')
				} else {
					Write-Verbose "`$TaskList '$TaskList' is an empty file."
					do {
						$ChoiceYesNo = Read-Host -Prompt "Create Task to associate with? [Y\N]"
						switch ($ChoiceYesNo) {
							'Y'	{ # Y - Yes
								Write-Verbose "Yes ('$ChoiceYesNo') option selected."
								Write-Verbose "Creating Task first, then Selecting it, then Starting Timer."
								#Write-Host `r`n
								Write-Verbose "Creating New Task."
								Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
								# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
								Create-NewTask -TaskListPath $TaskList -LogFilePath $sLogFile
								# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
								Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
								Write-Verbose "Select Newly Created Task."
								#Break #help about_Break
								#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
							}
							'N' { # N - No
								Write-Verbose "No ('$ChoiceYesNo') option selected."
								Write-Verbose "Proceeding with Timer without associating a Task."
								Write-Host `r`n
								$SelectedTaskLine = ""
								$SelectedTaskName = ""
								#Break #help about_Break
								#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
							}
							default { # Choice not recognized.
								Write-Host `r`n
								Write-Host "Choice `"$ChoiceYesNo`" not recognized. Options must me Yes or No."
								#Write-HorizontalRuleAdv -HRtype DashedLine
								Write-Host `r`n
								#Break #help about_Break
								PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
								Write-Host `r`n
								Write-HorizontalRuleAdv -HRtype DashedLine
							}
						}
					}
					until ($ChoiceYesNo -eq 'Y' -Or $ChoiceYesNo -eq 'N')
				}
			}
			
			#$TimeLog #CSV
			# Headers:
			# TimeStamp (YYYY-MM-DD_HH-MM-SS), Date (YYYY-MM-DD), Time (HH:MM:SS AM), TimeZone (MST), Hostname, TaskList_ID, TaskList_Name, TimeLog_Type, Pomodoro_Mode
			
			# TimeLog_Type:
			#$TimeLog_Type = "WorkStart"
			#$TimeLog_Type = "TimeStart"
			#$TimeLog_Type = "TimeStop"
			#$TimeLog_Type = "DistractionTimeStamp"
			#$TimeLog_Type = "PAUSE"
			#$TimeLog_Type = "UN-PAUSE"
			#$TimeLog_Type = "WorkStop"
			
			
			
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		'P' { # Select Pomodoro Mode - $ChoiceSelectPomodoroMode
			Write-Verbose "Select Pomodoro Mode."
			do
			{
				#CLS
				Write-Verbose "Start of Do loop."
				# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				Select-PomodoroMode
				# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				Write-Verbose "End of function."
				Write-Verbose "`$Pomodoro_Mode = '$Pomodoro_Mode'"
				Write-Verbose "`$Pomodoro_Choice = '$Pomodoro_Choice'"
				#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			}
			until ($Pomodoro_Choice -eq 'P' -Or $Pomodoro_Choice -eq 'E' -Or $Pomodoro_Choice -eq 'R' -Or $Pomodoro_Choice -eq 'T' -Or $Pomodoro_Choice -eq 'Q') 
			
			Break #help about_Break
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		1 { # Test #1 - $ChoiceTest
			Write-Verbose "Test #1."
			Write-Host `n
			Write-Host "Test #1."
			Write-HorizontalRuleAdv -HRtype DashedLine
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		'Q' { # Quit - $ChoiceQuit
			Write-Verbose "Quit option selected."
			Write-Host "Good Bye!!!" -ForegroundColor Green
			Return #help about_Return
			#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
		default { # Choice not recognized.
			Write-Host `n
			Write-Host "Choice `"$answer`" not recognized."
			Write-HorizontalRuleAdv -HRtype DashedLine
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
		}
		# -----------------------------------------------------------------------------------------------------------------------
	}
	Write-Verbose "End of switch choice cycle."
    #PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
}
until ($answer -eq 'Q') 

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-Verbose "/Script body."

# =======================================================================================================================

Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "End of script" $MyInvocation.MyCommand.Name
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Write-Host `n

#Script MAIN Execution ends here
#
#
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# =======================================================================================================================
# -----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Footer]---------------------------------------------------------

Write-Verbose "Script Main end. $ScriptName"
Write-Debug "End-of-script. $ScriptName"
Write-LogInfo -LogPath $sLogFile -Message "End of script $ScriptName"
Stop-Log -LogPath $sLogFile
Write-Output $sLogFile
Return # help about_Return
